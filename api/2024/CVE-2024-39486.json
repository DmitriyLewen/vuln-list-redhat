{
  "affected_release": null,
  "package_state": null,
  "threat_severity": "Low",
  "public_date": "2024-07-06T00:00:00Z",
  "bugzilla": {
    "description": "kernel: From NVD collector",
    "id": "2296094",
    "url": "https://bugzilla.redhat.com/show_bug.cgi?id=2296094"
  },
  "cvss": {
    "cvss_base_score": "",
    "cvss_scoring_vector": "",
    "status": ""
  },
  "cvss3": {
    "cvss3_base_score": "",
    "cvss3_scoring_vector": "",
    "status": ""
  },
  "iava": "",
  "cwe": "",
  "statement": "",
  "acknowledgement": "",
  "name": "CVE-2024-39486",
  "document_distribution": "",
  "details": [
    "In the Linux kernel, the following vulnerability has been resolved:\ndrm/drm_file: Fix pid refcounting race\nfilp-\u003epid is supposed to be a refcounted pointer; however, before this\npatch, drm_file_update_pid() only increments the refcount of a struct\npid after storing a pointer to it in filp-\u003epid and dropping the\ndev-\u003efilelist_mutex, making the following race possible:\nprocess A               process B\n=========               =========\nbegin drm_file_update_pid\nmutex_lock(\u0026dev-\u003efilelist_mutex)\nrcu_replace_pointer(filp-\u003epid, \u003cpid B\u003e, 1)\nmutex_unlock(\u0026dev-\u003efilelist_mutex)\nbegin drm_file_update_pid\nmutex_lock(\u0026dev-\u003efilelist_mutex)\nrcu_replace_pointer(filp-\u003epid, \u003cpid A\u003e, 1)\nmutex_unlock(\u0026dev-\u003efilelist_mutex)\nget_pid(\u003cpid A\u003e)\nsynchronize_rcu()\nput_pid(\u003cpid B\u003e)   *** pid B reaches refcount 0 and is freed here ***\nget_pid(\u003cpid B\u003e)   *** UAF ***\nsynchronize_rcu()\nput_pid(\u003cpid A\u003e)\nAs far as I know, this race can only occur with CONFIG_PREEMPT_RCU=y\nbecause it requires RCU to detect a quiescent state in code that is not\nexplicitly calling into the scheduler.\nThis race leads to use-after-free of a \"struct pid\".\nIt is probably somewhat hard to hit because process A has to pass\nthrough a synchronize_rcu() operation while process B is between\nmutex_unlock() and get_pid().\nFix it by ensuring that by the time a pointer to the current task's pid\nis stored in the file, an extra reference to the pid has been taken.\nThis fix also removes the condition for synchronize_rcu(); I think\nthat optimization is unnecessary complexity, since in that case we\nwould usually have bailed out on the lockless check above."
  ],
  "references": [
    "https://www.cve.org/CVERecord?id=CVE-2024-39486\nhttps://nvd.nist.gov/vuln/detail/CVE-2024-39486\nhttps://git.kernel.org/stable/c/0acce2a5c619ef1abdee783d7fea5eac78ce4844\nhttps://git.kernel.org/stable/c/16682588ead4a593cf1aebb33b36df4d1e9e4ffa\nhttps://git.kernel.org/stable/c/4f2a129b33a2054e62273edd5a051c34c08d96e9"
  ]
}